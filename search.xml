<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>javase-java类，对象和方法</title>
    <url>/2022/03/07/javase-java%E7%B1%BB%EF%BC%8C%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="面向过程和面向对象"><a href="#面向过程和面向对象" class="headerlink" title="面向过程和面向对象"></a>面向过程和面向对象</h2><blockquote>
<p>面向过程：是一种执行者思维 主要处理简单的逻辑问题</p>
<p>面向对象：是一种设计者思维 主要处理复杂问题</p>
<p>注意: 面向对象和面向过程是相辅相成的 我们对于事物分析 首先使用面向对象对事物进行宏观整体分析，在使用面向过程对事物进行微观的具体执行</p>
</blockquote>
<span id="more"></span>

<h2 id="类和对象之间的关系"><a href="#类和对象之间的关系" class="headerlink" title="类和对象之间的关系"></a>类和对象之间的关系</h2><blockquote>
<p>类：class 是一个模板</p>
<p>对象：具体的一个实例</p>
<p> 一个类可以产生无数个对象  java中所有的对象通过new 关键字体现的</p>
</blockquote>
<h2 id="类的组成"><a href="#类的组成" class="headerlink" title="类的组成"></a><strong>类的组成</strong></h2><p><code>Java中所有自定义类型都是引用类型</code></p>
<ul>
<li>成员变量</li>
<li>方法</li>
<li>构造方法</li>
</ul>
<h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a><strong>成员变量</strong></h3><blockquote>
<p>局部变量和成员变量之间区别<br>类中定义的变量是成员变量，而方法中定义的变量，包括方法的参数，代码块中定义的变量被称为局部变量<br>A、内存中位置不同   成员变量在 堆内存   局部变量是栈内存<br>B、是否有默认值  局部变量是没有    成员变量有    整数—0   浮点数—-0.0   布尔类型—-false   字符类型—‘\u0000’  引用数据类型—-null<br>C、作用范围   局部变量当前方法内有效    成员变量 在整个类中有有效的</p>
</blockquote>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a><strong>方法</strong></h3><p><code>方法的四种书写方式</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//[A]没有参数 没有返回值  ---- 如果方法没有返回值的使用 void</span></span><br><span class="line"> <span class="keyword">public</span>   <span class="keyword">void</span>    <span class="title function_">aa</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">     System.out.println(<span class="string">&quot;我是方法aa&quot;</span>);</span><br><span class="line">     <span class="comment">//bb(&quot;ceshi&quot;,12); ----在【一个类中】 直接调用【同一种类型】的方法 直接使用方法名进行调用即可</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//[B]有参数没有返回值----- String  a,int b  代表的是方法的参数 多个参数之间使用逗号(,)进行分割</span></span><br><span class="line"><span class="comment">//a  b  称为 形参代表的是形式上参数</span></span><br><span class="line"><span class="keyword">public</span>    <span class="keyword">void</span>    <span class="title function_">bb</span><span class="params">(String a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我是方法bb:&quot;</span>+a+<span class="string">&quot;--&quot;</span>+b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[C]有返回值没有参数 -----return 返回值  方法的返回值只可有一个</span></span><br><span class="line"><span class="comment">//那个位置调用cc方法  这个返回值就返回给谁</span></span><br><span class="line"><span class="keyword">public</span>   <span class="type">int</span>    <span class="title function_">cc</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我是ccc方法&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[D]有参数有返回值</span></span><br><span class="line"><span class="keyword">public</span>   String  <span class="title function_">dd</span><span class="params">(<span class="type">int</span> a,<span class="type">double</span> b)</span>&#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;我是方法dd:&quot;</span>+a+<span class="string">&quot;--&quot;</span>+b);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ceshi&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a><strong>方法重载</strong></h4><blockquote>
<p>在【一个类】中 出现了 【方法名相同】  【参数列表不同】  这种方法称为 方法的重载<br>参数列表不同  （只要满足一个就可以看成是参数列表不同）<br>   A、类型不同<br>   B、个数不同<br>   C、顺序（位置）不同<br>方法重载仅仅能够帮助我们更加方便的整理,归纳,记忆,调用 方法.<br>方法重载没有提高任何效率,也没有节约任何代码.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a><strong>构造方法</strong></h3><blockquote>
<p>注意：</p>
<ul>
<li>构造方法的方法名必须和类名一致！</li>
<li>构造方法通过new关键字调用！！</li>
<li>构造方法虽然有返回值，但是不能定义返回值类型(返回值的类型肯定是本类)，不能在构造器里使用return返回某个值。</li>
<li>如果我们没有定义构造方法，则编译器会自动定义一个【无参的构造方法】。如果已定义则编译器不会自动添加！</li>
<li>构造方法可以重载</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lee.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">public</span> String name ;</span><br><span class="line">    <span class="keyword">public</span> String color ;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> price ;</span><br><span class="line">    <span class="keyword">public</span> String storage ;</span><br><span class="line">    <span class="comment">//构造方法 无参</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Phone</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	<span class="comment">//构造方法 有参</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Phone</span><span class="params">(String name, String color, <span class="type">double</span> price, String storage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">        <span class="built_in">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法重载根据参数个数，类型和顺序调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aa</span> <span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是aa方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aa</span> <span class="params">(<span class="type">int</span> a,String b)</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是aa方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aa</span> <span class="params">(String b,<span class="type">int</span> a)</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是aa方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">//类</span></span><br><span class="line"><span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>(); <span class="comment">//通过new关键字获取Phone类的实例化对象 无参</span></span><br><span class="line"><span class="type">Phone</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>(<span class="string">&quot;华为手机&quot;</span>,<span class="string">&quot;白色&quot;</span>,<span class="number">2500</span>,<span class="string">&quot;256G&quot;</span>); <span class="comment">//通过new关键字获取Phone类的实例化对象 有参</span></span><br><span class="line"></span><br><span class="line">System.out.println(phone.name);</span><br><span class="line">System.out.println(phone.price);</span><br><span class="line"><span class="comment">//由于未赋初始值 取默认值</span></span><br><span class="line"><span class="comment">//null</span></span><br><span class="line"><span class="comment">//0.0</span></span><br><span class="line">System.out.println(phone2.name);</span><br><span class="line">System.out.println(phone2.price);</span><br><span class="line"><span class="comment">//华为手机</span></span><br><span class="line"><span class="comment">//2500.0</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p> this关键字  —-&gt;创建好的对象的地址</p>
<p>作用：<br>    A、解决局部变量名称和成员变量名称冲突的时候获得值的问题—-this.属性<br>    B、解决了构造方法之间相互的调用—-this()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">public</span> String name ;</span><br><span class="line">    <span class="keyword">public</span> String color ;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> price ;</span><br><span class="line">    <span class="keyword">public</span> String storage ;</span><br><span class="line">    <span class="comment">//构造方法 无参</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Phone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//在构造方法中相互调用</span></span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;华为手机&quot;</span>,<span class="string">&quot;白色&quot;</span>,<span class="number">2500</span>,<span class="string">&quot;256G&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//构造方法 有参</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Phone</span><span class="params">(String name, String color, <span class="type">double</span> price, String storage)</span> &#123;</span><br><span class="line">        <span class="comment">//this();</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">        <span class="built_in">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p><strong>类和对象在内存中的执行</strong></p>
<p>通过类加载器将类的信息加载到jvm中的方法区中 方法区存放类信息对象信息、常量、静态变量和其他信息</p>
<p>通过new实例化对象时</p>
<ol>
<li>分配对象空间，并将对象成员变量初始化为0或null</li>
<li>执行属性值的显示初始化</li>
<li>执行构造方法</li>
<li>返回对象的地址给相关的变量</li>
</ol>
<p>所以栈中存放的是stu的地址值 指向堆中存放的地址，每实例化一个对象就会在堆中开辟一片空间并将地址值返回  this关键字代表创建好的对象的地址 如stu的this.age相当于0x111.age</p>
<p>当执行方法时将从方法区中将类的方法压入栈中 执行完后出栈</p>
<p><img src="/../images/1646659075342.png" alt="1646742249430"></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>javase-java类静态、封装、继承</title>
    <url>/2022/03/08/javase-java%E7%B1%BB%E9%9D%99%E6%80%81%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>可以使用static 修饰成员变量 | 方法|代码块。</p>
<h3 id="static修饰成员变量"><a href="#static修饰成员变量" class="headerlink" title="static修饰成员变量"></a>static修饰成员变量</h3><blockquote>
<p>静态成员变量存在方法区中  并且只有一份<br>静态成员变量是被所有对象所共享的<br>静态成员变量属于类  所以在使用的时候不需要创建对象的直接使用 【类名.静态成员变量】名即可<br>静态成员变量 在类加载后就可以完成初始化 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> age; <span class="comment">//静态成员</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//Student.age  可直接访问 无需实例化</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        stu.name=<span class="string">&quot;zs&quot;</span>;</span><br><span class="line">        stu2.name=<span class="string">&quot;ls&quot;</span>;</span><br><span class="line"></span><br><span class="line">        stu.age = <span class="number">12</span>;</span><br><span class="line">        stu2.age = <span class="number">18</span>;</span><br><span class="line">        System.out.println(stu.name); <span class="comment">//zs</span></span><br><span class="line">        System.out.println(stu2.name); <span class="comment">//ls</span></span><br><span class="line">        System.out.println(stu.age);  <span class="comment">//18</span></span><br><span class="line">        System.out.println(stu2.age); <span class="comment">//18</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>



<h3 id="静态成员在内存中"><a href="#静态成员在内存中" class="headerlink" title="静态成员在内存中"></a>静态成员在内存中</h3><p>由于静态成员在类加载中完成初始化且只初始化一次，因此可以直接<code>类名.静态变量</code>调用无需实例化对象 再者被类的所有对象共享 所以当一个对象访问后所有对象都受到影响</p>
<p><img src="/../images/1646744144370.png" alt="1646744144370"></p>
<p><strong>static变量和非static变量的区别：</strong></p>
<ul>
<li><p>份数不同：静态变量：1份；非静态变量：1个对象一份</p>
</li>
<li><p>存储位置不同：静态变量：方法区；非静态变量：堆中</p>
</li>
<li><p>内存分配空间的时间不同：静态变量：第一次加载类的时候；非静态变量：创建对象的时候</p>
</li>
<li><p>生命周期不同。静态变量和类的生命周期相同；非静态变量的生命周期和所属对象相同</p>
</li>
<li><p>调用方式不同</p>
<p>  静态变量：  通过类名调用  Student.classRoom</p>
<p> 也可以通过对象名调用stu1.classRoom &#x3D;”301” 不推荐</p>
<p>  非静态变量：通过对象名调用    stu1.name &#x3D;”小张”;</p>
</li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="static修饰成员方法"><a href="#static修饰成员方法" class="headerlink" title="static修饰成员方法"></a>static修饰成员方法</h3><blockquote>
<p>静态方法直接使用<code>类名.方法名()</code> 不需要创建对象<br><code>静态方法中不可以直接使用非静态内容</code>（非静态变量&#x2F;非静态方法）<br>静态方法中不可以写this关键字<br>非静态方法是可以直接使用静态内容（静态方法&#x2F;静态变量）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * static修饰的方法叫做静态成员方法</span></span><br><span class="line"><span class="comment">    *   静态成员方法中只能直接使用静态成员变量</span></span><br><span class="line"><span class="comment">    *   静态成员方法推荐使用类名.方法名方式调用</span></span><br><span class="line"><span class="comment">    *   静态成员方法中不能使用this关键</span></span><br><span class="line"><span class="comment">    *   静态成员方法只能直接调用其他静态成员方法</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 姓 名属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String firstName;</span><br><span class="line">    <span class="keyword">public</span> String lastName;</span><br><span class="line">    <span class="comment">// 显示姓名的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showName</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(firstName+<span class="built_in">this</span>.lastName);</span><br><span class="line">        methodA();</span><br><span class="line">        methodB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">viewName</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(firstName<span class="comment">/*+lastName*/</span>);</span><br><span class="line">        methodA();</span><br><span class="line">        <span class="comment">//methodB();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String lastName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="static修饰代码块"><a href="#static修饰代码块" class="headerlink" title="static修饰代码块"></a>static修饰代码块</h3><blockquote>
<p>普通代码块:（执行多次）<br>    [1]在构造方法之前执行 并且每创建一次对象 就会执行一次普通代码块中内容<br>    [2]作用:给参数进行初始化赋值的操作 (使用情况非常少)<br> 静态代码块：(执行一次)<br>    [1]在类加载的时候执行  只会执行一次<br>    [2] A、给静态成员变量进行初始化赋值的操作  B、初始化解析加载一些配置文件(例如我们以后学习的xml)</p>
<p> 执行顺序 静态代码块 &gt; 普通代码块 &gt;构造器</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">19</span>;</span><br><span class="line">    <span class="keyword">private</span> String name=<span class="string">&quot;张三&quot;</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//顺序 静态代码块&gt;普通代码块&gt;构造</span></span><br><span class="line">    <span class="comment">//每次实例化执行  可看作匿名函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//类加载时候执行 只执行一次 给静态变量赋值或加载配置文件</span></span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aa</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> age=<span class="number">12</span>;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态调用 类名.方法名/变量名  不可在非静态方法中调用</span></span><br><span class="line">    <span class="comment">//静态方法中不可使用this关键字</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bb</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">// aa(); //错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><blockquote>
<p>优点 在调用方法的时候比较的方便 使用时候比较简单 不需要创建对象<br> 缺点：静态内容的产生比较占用内存   由于数据的共享 会导致数据的混淆 从而导致线程不安全</p>
</blockquote>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><blockquote>
<p>作用：可以更好的保护变量 使代码变得更加安全<br>实现: 成员变量私有化 提供公共的get&#x2F;set方法 供用户使用即可</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Base</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getColor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><blockquote>
<p>作用：实现代码的复用</p>
<ol>
<li>父类也称作超类、基类。子类：派生类等。</li>
<li>Java中只有单继承，没有像C++那样的多继承。多继承会引起混乱，使得继承链过于复杂，系统难于维护。</li>
<li>子类继承父类，可以得到父类的全部属性和方法 (除了父类的构造方法)，但不见得可以直接访问(比如，父类私有的属性和方法)。</li>
<li>如果定义一个类时，没有调用extends，则它的父类是：java.lang.Object。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Base</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Base</span><span class="params">(String color, String name, <span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getColor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Phone</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSize</span><span class="params">(String size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line"><span class="comment">//子类中没有这两个方法 继承自父类</span></span><br><span class="line">phone.setName(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">phone.getName();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
</search>
