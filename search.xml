<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux服务器中配置Nginx一个域名访问多个项目</title>
    <url>/2020/04/12/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E9%85%8D%E7%BD%AENginx%E4%B8%80%E4%B8%AA%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AE%E5%A4%9A%E4%B8%AA%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>&amp;emsp;&amp;emsp;务器配置个人博客和其它项目使其能够根据不同 url 跳转到不同项目，(例如:<em>localhosh:&#x2F;&#x2F;A 项目&#x2F;，localhosh:&#x2F;&#x2F;B 项目&#x2F;</em> )因为对服务器和 Nginx 部署了解甚少，在此记录一下</p>
<span id="more"></span>

<h2 id="location-模块的匹配介绍"><a href="#location-模块的匹配介绍" class="headerlink" title="location 模块的匹配介绍"></a>location 模块的匹配介绍</h2><blockquote>
<ol>
<li>”&#x3D;”前缀指令匹配，如果匹配成功，则停止其他匹配。</li>
<li>普通字符串指令匹配，顺序是从长到短，匹配成功的 location 如果使用^~，则停止其他匹配（正则匹配）。</li>
<li>正则表达式指令匹配，按照配置文件里的顺序，成功就停止其他匹配。</li>
<li>如果第三步中有匹配成功，则使用该结果，否则使用第二步结果。</li>
</ol>
</blockquote>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><blockquote>
<ol>
<li>匹配的顺序是先匹配普通字符串，然后再匹配正则表达式。另外普通字符串匹配顺序是根据配置中字符长度从长到短，也就是说使用普通字符串配置的 location 顺序是无关紧要的，反正最后 nginx 会根据配置的长短来进行匹配，但是需要注意的是正则表达式按照配置文件里的顺序测试。找到第一个匹配的正则表达式将停止搜索。</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>一般情况下，匹配成功了普通字符串 location 后还会进行正则表达式 location 匹配。有两种方法改变这种行为，其一就是使用“&#x3D;”前缀，这时执行的是严格匹配，并且匹配成功后立即停止其他匹配，同时处理这个请求；另外一种就是使用“^~”前缀，如果把这个前缀用于一个常规字符串那么告诉 nginx 如果路径匹配那么不测试正则表达式。</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">location = <span class="string">``</span> / uri;</span><br></pre></td></tr></table></figure>

<p>&#x3D;开头表示精确匹配，只有完全匹配上才能生效。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">location ^ (~<span class="string">``</span> / uri);</span><br></pre></td></tr></table></figure>

<p>^~ 开头对 URL 路径进行前缀匹配，并且在正则之前。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">location ~ pattern</span><br></pre></td></tr></table></figure>

<p>~开头表示区分大小写的正则匹配。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">location ~* pattern</span><br></pre></td></tr></table></figure>

<p>~*开头表示不区分大小写的正则匹配。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">location<span class="string">``</span> / uri;</span><br></pre></td></tr></table></figure>

<p>不带任何修饰符，也表示前缀匹配，但是在正则匹配之后。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">location /</span><br></pre></td></tr></table></figure>

<p>通用匹配，任何未匹配到其它 location 的请求都会匹配到，相当于 switch 中的 default。</p>
<h2 id="alias-和-root-的区别"><a href="#alias-和-root-的区别" class="headerlink" title="alias 和 root 的区别"></a>alias 和 root 的区别</h2><p>在<a href="https://router.vuejs.org/zh/guide/essentials/redirect-and-alias.html#%E9%87%8D%E5%AE%9A%E5%90%91">VUE</a>中也有alias的概念，感觉两者差不多</p>
<ul>
<li>alias 和 root 都是用来指定文件路径的，root与alias主要区别在于nginx如何解释location后面的uri，这会使两者分别以不同的方式将请求映射到服务器文件上。</li>
<li>root的处理结果是：root路径＋location路径</li>
<li>alias的处理结果是：使用alias路径替换location路径</li>
<li>alias是一个目录别名的定义，root则是最上层目录的定义。</li>
<li>还有一个重要的区别是alias后面必须要用“&#x2F;”结束，否则会找不到文件</li>
<li>alias在使用正则匹配时，必须捕捉要匹配的内容并在指定的内容处使用。</li>
<li>alias只能位于location块中。（root可以不放在location中）</li>
</ul>
<h2 id="配置示例"><a href="#配置示例" class="headerlink" title="配置示例"></a>配置示例</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line"> *****</span><br><span class="line"> *****</span><br><span class="line"> # 域名+项目<span class="number">1</span>名称</span><br><span class="line"> location ^~ <span class="regexp">/A/</span> &#123;</span><br><span class="line">   alias /data/A/;</span><br><span class="line"> &#125;</span><br><span class="line"> # 域名+项目<span class="number">2</span>名称</span><br><span class="line"> location ^~ <span class="regexp">/B/</span> &#123;</span><br><span class="line">   alias /data/B/;</span><br><span class="line"> &#125;</span><br><span class="line">    ****</span><br><span class="line">    ****</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://www.nginx.cn/4658.html">nginx的location、root、alias指令用法和区别</a></p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中的prototype、__proto__与constructor</title>
    <url>/2020/04/18/JS%E4%B8%AD%E7%9A%84prototype%E3%80%81-proto-%E4%B8%8Econstructor/</url>
    <content><![CDATA[<p>​    原文链接 <a href="https://blog.csdn.net/cc18868876837/article/details/81211729">https://blog.csdn.net/cc18868876837/article/details/81211729</a></p>
<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>作为一名前端工程师，必须搞懂JS中的prototype、_ _ proto_ _ 与constructor属性，相信很多初学者对这些属性存在许多困惑，容易把它们混淆，本文旨在帮助大家理清它们之间的关系并彻底搞懂它们。这里说明一点，_ _ proto_ _ 属性的两边是各由两个下划线构成（这里为了方便大家看清，在两下划线之间加入了一个空格：_ <em>proto</em> <em>，读作“dunder proto”，“double underscore proto”的缩写），实际上，该属性在ES标准定义中的名字应该是[[Prototype]]，具体实现是由浏览器代理自己实现，谷歌浏览器的实现就是将[[Prototype]]命名为</em> _ proto_ _ ，大家清楚这个标准定义与具体实现的区别即可（名字有所差异，功能是一样的），可以通过该方式检测引擎是否支持这个属性：Object.getPrototypeOf({_ _ proto_ _ : null}) &#x3D;&#x3D;&#x3D; null。本文基于谷歌浏览器（版本 72.0.3626.121）的实验结果所得。</p>
<span id="more"></span>
<p>     现在正式开始！ 让我们从如下一个简单的例子展开讨论，并配以相关的图帮助理解：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;...&#125;;</span><br><span class="line"><span class="keyword">let</span> f1 = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br></pre></td></tr></table></figure>

<p>以上代码表示创建一个构造函数Foo()，并用new关键字实例化该构造函数得到一个实例化对象f1。这里稍微补充一下new操作符将函数作为构造器进行调用时的过程：函数被调用，然后新创建一个对象，并且成了函数的上下文（也就是此时函数内部的this是指向该新创建的对象，这意味着我们可以在构造器函数内部通过this参数初始化值），最后返回该新对象的引用，详细请看：详解JavaScript中的new操作符。虽然是简简单单的两行代码，然而它们背后的关系却是错综复杂的，如下图所示：<br>看到这图别怕，让我们一步步剖析，彻底搞懂它们！</p>
<p><img src="https://raw.githubusercontent.com/zjt-wy/images/master/js/1%20(6).png"></p>
<p>  图的说明：右下角为图例，红色箭头表示_ _ proto_ _ 属性指向、绿色箭头表示prototype属性的指向、棕色实线箭头表示本身具有的constructor属性的指向，棕色虚线箭头表示继承而来的constructor属性的指向；蓝色方块表示对象，浅绿色方块表示函数（这里为了更好看清，Foo()仅代表是函数，并不是指执行函数Foo后得到的结果，图中的其他函数同理）。图的中间部分即为它们之间的联系，图的最左边即为例子代码。</p>
<h3 id="2-proto-属性"><a href="#2-proto-属性" class="headerlink" title="2. _ _ proto _ _ 属性"></a>2. _ _ proto _ _ 属性</h3><p>  首先，我们需要牢记两点：①_ _ proto_ _ 和constructor属性是对象所独有的；② prototype属性是函数所独有的。但是由于JS中函数也是一种对象，所以函数也拥有_ _ proto_ _ 和constructor属性，这点是致使我们产生困惑的很大原因之一。上图有点复杂，我们把它按照属性分别拆开，然后进行分析：</p>
<p><img src="https://raw.githubusercontent.com/zjt-wy/images/master/js/1%20(5).png"></p>
<p>  第一，这里我们仅留下 _ <em>proto</em> _ 属性，它是对象所独有的，可以看到_ _ proto_ _ 属性都是由一个对象指向一个对象，即指向它们的原型对象（也可以理解为父对象），那么这个属性的作用是什么呢？它的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的_ _ proto_ _ 属性所指向的那个对象（可以理解为父对象）里找，如果父对象也不存在这个属性，则继续往父对象的_ _ proto_ _ 属性所指向的那个对象（可以理解为爷爷对象）里找，如果还没找到，则继续往上找…直到原型链顶端null（可以理解为原始人。。。），再往上找就相当于在null上取值，会报错（可以理解为，再往上就已经不是“人”的范畴了，找不到了，到此结束，null为原型链的终点），由以上这种通过_ _ proto_ _ 属性来连接对象直到null的一条链即为我们所谓的原型链。<br>  其实我们平时调用的字符串方法、数组方法、对象方法、函数方法等都是靠_ _ proto_ _ 继承而来的。</p>
<h3 id="3-prototype属性"><a href="#3-prototype属性" class="headerlink" title="3. prototype属性"></a>3. prototype属性</h3><p>  第二，接下来我们看 prototype 属性：</p>
<p>  <img src="https://raw.githubusercontent.com/zjt-wy/images/master/js/1%20(4).png"></p>
<p>prototype属性，别忘了一点，就是我们前面提到要牢记的两点中的第二点，它是函数所独有的，它是从一个函数指向一个对象。它的含义是函数的原型对象，也就是这个函数（其实所有函数都可以作为构造函数）所创建的实例的原型对象，由此可知：f1._ _ proto_ _  &#x3D;&#x3D;&#x3D; Foo.prototype，它们两个完全一样。那prototype属性的作用又是什么呢？它的作用就是包含可以由特定类型的所有实例共享的属性和方法，也就是让该函数所实例化的对象们都可以找到公用的属性和方法。任何函数在创建的时候，其实会默认同时创建该函数的prototype对象。</p>
<h3 id="4-constructor属性"><a href="#4-constructor属性" class="headerlink" title="4. constructor属性"></a>4. constructor属性</h3><p>最后，我们来看一下 constructor 属性：<br>    <img src="https://raw.githubusercontent.com/zjt-wy/images/master/js/1%20(3).png"><br>    constructor属性也是对象才拥有的，它是从一个对象指向一个函数，含义就是指向该对象的构造函数，每个对象都有构造函数（本身拥有或继承而来，继承而来的要结合_ _ proto_ _ 属性查看会更清楚点，如下图所示），从上图中可以看出Function这个对象比较特殊，它的构造函数就是它自己（因为Function可以看成是一个函数，也可以是一个对象），所有函数和对象最终都是由Function构造函数得来，所以constructor属性的终点就是Function这个函数。<br><img src="https://raw.githubusercontent.com/zjt-wy/images/master/js/1%20(2).png"></p>
<p>  感谢网友的指出，这里解释一下上段中“每个对象都有构造函数”这句话。这里的意思是每个对象都可以找到其对应的constructor，因为创建对象的前提是需要有constructor，而这个constructor可能是对象自己本身显式定义的或者通过_ _ proto_ _ 在原型链中找到的。而单从constructor这个属性来讲，只有prototype对象才有。每个函数在创建的时候，JS会同时创建一个该函数对应的prototype对象，而函数创建的对象._ _ proto_ _  &#x3D;&#x3D;&#x3D; 该函数.prototype，该函数.prototype.constructor&#x3D;&#x3D;&#x3D;该函数本身，故通过函数创建的对象即使自己没有constructor属性，它也能通过_ _ proto_ _ 找到对应的constructor，所以任何对象最终都可以找到其构造函数（null如果当成对象的话，将null除外）。如下：<br><img src="https://raw.githubusercontent.com/zjt-wy/images/master/js/1%20(1).png"></p>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h3><p>我们需要牢记两点：①_ _ proto_ _ 和constructor属性是对象所独有的；② prototype属性是函数所独有的，因为函数也是一种对象，所以函数也拥有_ _ proto_ _ 和constructor属性。<br>_ _ proto_ _ 属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的_ _ proto_ _ 属性所指向的那个对象（父对象）里找，一直找，直到_ _ proto_ _ 属性的终点null，再往上找就相当于在null上取值，会报错。通过_ _ proto_ _ 属性将对象连接起来的这条链路即我们所谓的原型链。<br>prototype属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即f1._ _ proto_ _  &#x3D;&#x3D;&#x3D; Foo.prototype。<br>constructor属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向Function。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">say</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> person=<span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">__proto__</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">__proto__</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/03/02/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>hexo搭建</title>
    <url>/2020/04/12/hexo%E6%90%AD%E5%BB%BA%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<h4 id="服务器搭建nginx"><a href="#服务器搭建nginx" class="headerlink" title="服务器搭建nginx"></a>服务器搭建nginx</h4><p><a href="https://yq.aliyun.com/articles/700682">在阿里云服务器上如何搭建nginx？</a> </p>
<h4 id="解决本地git提交-问题"><a href="#解决本地git提交-问题" class="headerlink" title="解决本地git提交 问题"></a>解决本地git提交 问题</h4><p><a href="https://blog.csdn.net/lujinjian605894472/article/details/8443403">![rejected] master -&gt; master (non-fast-forward)</a></p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>lambda函数</title>
    <url>/2020/05/06/lambda%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="python-lambda函数"><a href="#python-lambda函数" class="headerlink" title="python lambda函数"></a>python lambda函数</h3><blockquote>
<p>匿名函数lambda：是指一类无需定义标识符（函数名）的函数或子程序。<br>lambda 函数可以接收任意多个参数 (包括可选参数) 并且返回单个表达式的值。</p>
<p>lambda匿名函数的格式：冒号前是参数，可以有多个，用逗号隔开，冒号右边的为表达式。其实lambda返回值是一个函数的地址，也就是函数对象。</p>
</blockquote>
<p><strong>要点：</strong></p>
<ul>
<li>lambda 函数不能包含命令，</li>
<li>包含的表达式不能超过一个。<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x</span>):</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span> * x + <span class="number">1</span></span><br><span class="line">func(<span class="number">5</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;等同于&#x27;&#x27;&#x27;</span></span><br><span class="line">a = <span class="keyword">lambda</span> x : <span class="number">2</span> * x + <span class="number">1</span></span><br><span class="line">a(<span class="number">5</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>多个参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x,y</span>):</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span> * x + y</span><br><span class="line">func(<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;等同于&#x27;&#x27;&#x27;</span></span><br><span class="line">a = <span class="keyword">lambda</span> x,y : <span class="number">2</span> * x + y</span><br><span class="line">a(<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>post常见四种提交方式及php接收</title>
    <url>/2020/04/23/post%E5%B8%B8%E8%A7%81%E5%9B%9B%E7%A7%8D%E6%8F%90%E4%BA%A4%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<ul>
<li>application&#x2F;x-www-form-urlencoded</li>
<li>multipart&#x2F;form-data</li>
<li>application&#x2F;json</li>
<li>text&#x2F;xml</li>
</ul>
<p>以上是四种常见的<code>POST</code>提交数据的方式，<code>HTTP</code> 协议是以 ASCII 码传输（可参考<a href="https://zh.wikipedia.org/zh-hans/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">http介绍</a>），建立在 TCP&#x2F;IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：<code>状态行</code>、<code>请求头</code>、<code>消息主体</code>。类似于下面这样</p>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;method&gt; &lt;request-<span class="variable constant_">URL</span>&gt; &lt;version&gt;</span><br><span class="line">&lt;headers&gt;</span><br><span class="line">&lt;entity-body&gt;</span><br></pre></td></tr></table></figure>

<p>协议规定 <code>POST</code> 提交的数据必须放在<code>消息主体（entity-body）</code>中，但协议并没有规定数据必须使用什么编码方式。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的 HTTP 请求满足上面的格式就可以。</p>
<p>但是，数据发送出去，还要服务端解析成功才有意义。一般服务端语言如 php、python 等，以及它们的 framework，都内置了自动解析常见数据格式的功能。服务端通常是根据请求头（headers）中的 <code>Content-Type</code> 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。所以说到 <code>POST</code> 提交数据方案，包含了 <code>Content-Type</code> 和<code>消息主体编码方式</code>两部分</p>
<h3 id="1-application-x2F-x-www-form-urlencoded"><a href="#1-application-x2F-x-www-form-urlencoded" class="headerlink" title="1.application&#x2F;x-www-form-urlencoded"></a>1.application&#x2F;x-www-form-urlencoded</h3><p>浏览器的原生<code>form</code> 表单，如果不设置<code>enctype</code>属性，那么最终就会以 <code>application/x-www-form-urlencoded</code> 方式提交数据 例如</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>  <span class="attr">role</span>=<span class="string">&quot;form&quot;</span>  <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">action</span>=<span class="string">&quot;index.php&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最为常见的form表单提交他的请求格式是这样的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">POST</span> <span class="attr">http</span>:<span class="comment">//www.example.com HTTP/1.1</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: application/x-www-form-urlencoded;charset=utf-<span class="number">8</span></span><br><span class="line"><span class="title class_">Form</span> <span class="title class_">Data</span></span><br><span class="line"> title=test&amp;sub%5B%5D=<span class="number">1</span>&amp;sub%5B%5D=<span class="number">2</span>&amp;sub%5B%5D=<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>1.首先，<code>Content-Type</code> 被指定为<code>application/x-www-form-urlencoded</code>；</p>
<p>2.headers最下方的格式为Form Data 提交的数据按照 <code>key1=val1&amp;key2=val2</code> 的方式进行编码，key 和 val 都进行了 URL 转码。大部分服务端语言都对这种方式有很好的支持，例如php 接收</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$title</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;title&#x27;</span>]; <span class="comment">//获取到title</span></span><br><span class="line"><span class="variable">$sub</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;sub&#x27;</span>] <span class="comment">//获取到sub数组</span></span><br></pre></td></tr></table></figure>

<p>很多时候，我们用 Ajax 提交数据时，也是使用这种方式。例如 <a href="http://jquery.com/">JQuery</a> 和 <a href="http://www.qwrap.com/">QWrap</a> 的 Ajax，Content-Type 默认值都是「application&#x2F;x-www-form-urlencoded;charset&#x3D;utf-8」</p>
<h3 id="2-multipart-x2F-form-data"><a href="#2-multipart-x2F-form-data" class="headerlink" title="2.multipart&#x2F;form-data"></a>2.multipart&#x2F;form-data</h3><p>常用于form表单上传文件时使用，与 <code>application/x-www-form-urlencoded</code>相比 form多了 <code>enctype=&quot;multipart/form-data&quot;</code> 属性 例如</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>  <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span> <span class="attr">action</span>=<span class="string">&quot;upload.php&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span>  <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>请求格式为</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">POST</span> <span class="attr">http</span>:<span class="comment">//www.example.com HTTP/1.1</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>:multipart/form-data; boundary=----<span class="title class_">WebKitFormBoundaryrGKCBY7</span>qhFd3TrwA</span><br><span class="line">------<span class="title class_">WebKitFormBoundaryrGKCBY7</span>qhFd3TrwA</span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Disposition</span>: form-data; name=<span class="string">&quot;text&quot;</span></span><br><span class="line">title</span><br><span class="line">------<span class="title class_">WebKitFormBoundaryrGKCBY7</span>qhFd3TrwA</span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Disposition</span>: form-data; name=<span class="string">&quot;file&quot;</span>; filename=<span class="string">&quot;chrome.png&quot;</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: image/png</span><br><span class="line"><span class="variable constant_">PNG</span> ... content <span class="keyword">of</span> chrome.<span class="property">png</span> ...</span><br><span class="line">------<span class="title class_">WebKitFormBoundaryrGKCBY7</span>qhFd3TrwA--</span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;name&#x27;</span>]; <span class="comment">//接收文件</span></span><br><span class="line"><span class="variable">$a</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>] <span class="comment">//接受普通数据 </span></span><br></pre></td></tr></table></figure>



<h3 id="3-application-x2F-json"><a href="#3-application-x2F-json" class="headerlink" title="3.application&#x2F;json"></a>3.application&#x2F;json</h3><p>  <code>application/json</code> 这个 <code>Content-Type</code>作为响应头大家肯定不陌生。实际上，现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 <code>JSON</code> 字符串。由于 <code>JSON</code>规范的流行，除了低版本 IE 之外的各大浏览器都原生支持 <code>JSON.stringify</code>，服务端语言也都有处理 <code>JSON</code> 的函数，使用<code>JSON</code>不会遇上什么麻烦。 <code>JSON</code>格式支持比键值对复杂得多的结构化数据，这一点也很有用。</p>
<p>格式如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">POST</span> <span class="attr">http</span>:<span class="comment">//www.example.com HTTP/1.1</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: application/json;charset=utf-<span class="number">8</span></span><br><span class="line"><span class="title class_">Request</span> <span class="title class_">Payload</span> </span><br><span class="line">  &#123;<span class="string">&quot;title&quot;</span>:<span class="string">&quot;test&quot;</span>,<span class="string">&quot;sub&quot;</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是 前两种form提交格式为 <code>Form Data</code> 这种为<code>Request Payload</code> 关于二者的区别可以参考 <a href="https://segmentfault.com/a/1190000018774494">https://segmentfault.com/a/1190000018774494</a>  这篇文章。</p>
<p>这种格式对php来说是不识别的，他只能解析成文本，所以后台接收原始流</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$data</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&quot;php://input&quot;</span>);</span><br><span class="line"><span class="variable">$data</span> = <span class="title function_ invoke__">json_decode</span>(<span class="variable">$data</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h3 id="4-text-x2F-xml"><a href="#4-text-x2F-xml" class="headerlink" title="4.text&#x2F;xml"></a>4.text&#x2F;xml</h3><p>  它是一种使用 <code>HTTP</code>作为传输协议，<code>XML</code> 作为编码方式的远程调用规范。典型的<code>XML-RPC</code>请求是这样的：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">POST http://www.example.com HTTP/1.1</span><br><span class="line">Content-Type: text/xml</span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">methodCall</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">methodName</span>&gt;</span>examples.getStateName<span class="tag">&lt;/<span class="name">methodName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">params</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span><span class="tag">&lt;<span class="name">i4</span>&gt;</span>41<span class="tag">&lt;/<span class="name">i4</span>&gt;</span><span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">params</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">methodCall</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>XML-RPC</code> 协议简单、功能够用，各种语言的实现都有。比如微信的<code>小程序</code>和<code>公众平台</code>都是使用它来作为基本的传输类型，它的使用也很广泛，如 <code>WordPress</code> 的 <a href="http://codex.wordpress.org/XML-RPC_WordPress_API">XML-RPC Api</a>，搜索引擎的 <a href="http://www.baidu.com/search/blogsearch_help.html#n7">ping 服务</a>等等。<code>JavaScript</code> 中，也有<a href="http://plugins.jquery.com/xmlrpc/">现成的库</a>支持以这种方式进行数据交互，能很好的支持已有的 <code>XML-RPC</code>服务。不过，我个人觉得<code>XML</code> 结构还是过于臃肿，一般场景用 <code>JSON</code>会更灵活方便</p>
<p>同上，这种结构php不认识，可使用 <strong>file_get_contents(‘php:&#x2F;&#x2F;input’)</strong> 进行接收</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p> 以上方法都可以通过header头部的Content-Type来指定  header: {“Content-Type”: “xxx” }</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown基本语法</title>
    <url>/2020/04/12/markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h4 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**这是加粗的文字**</span><br><span class="line">*这是倾斜的文字*`</span><br><span class="line">***这是斜体加粗的文字***</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure>

<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line">&gt;&gt;这是引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure>

<h4 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line">***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure>

<h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![图片alt](图片地址 &#x27;&#x27;图片title&#x27;&#x27;)</span><br><span class="line"> </span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br></pre></td></tr></table></figure>

<h4 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[超链接名](超链接地址 &quot;超链接title&quot;)</span><br><span class="line">title可加可不加</span><br></pre></td></tr></table></figure>

<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br><span class="line"> </span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br></pre></td></tr></table></figure>

<h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"> </span><br><span class="line">注意：</span><br><span class="line">1.第二行分割表头和内容“-”有一个就行，为了对齐，多加了几个</span><br><span class="line">2.文字默认居左，“-”两边加：表示文字居中；“-”右边加：表示文字居右</span><br></pre></td></tr></table></figure>

<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">​   ``` 语言类型 如 js / html / php</span><br><span class="line">    代码...</span><br><span class="line">    代码...</span><br><span class="line">    代码...</span><br><span class="line">​   ```</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>python-filter函数</title>
    <url>/2020/05/06/python-filter%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="python-filter函数"><a href="#python-filter函数" class="headerlink" title="python filter函数"></a>python filter函数</h3><blockquote>
<p><strong>filter()</strong> 函数用于过滤序列，过滤掉不符合条件的元素，返回一个迭代器对象，如果要转换为列表，可以使用 list() 来转换。</p>
</blockquote>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">filter</span>(function, iterable)</span><br></pre></td></tr></table></figure>

<p>参数</p>
<ul>
<li>function – 判断函数，可为none。</li>
<li>iterable – 可迭代对象。</li>
</ul>
<p>序列中的每个元素作为参数传递给函数进行判断，返回True或者False，最后将<code>返回为True的元素</code></p>
<h5 id="为None时"><a href="#为None时" class="headerlink" title="为None时"></a>为None时</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">filter</span>(<span class="literal">None</span>,[<span class="number">1</span>,<span class="literal">False</span>,<span class="number">0</span>,<span class="literal">True</span>])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(a))</span><br><span class="line"><span class="comment">#&lt;filter object at 0x00000169BBEA3550&gt;</span></span><br><span class="line"><span class="comment">#[1, True] </span></span><br></pre></td></tr></table></figure>

<h5 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> a = <span class="built_in">filter</span>(<span class="keyword">lambda</span> n : n &lt; <span class="number">2</span>,[<span class="number">0</span>,<span class="literal">False</span>,<span class="number">2</span>,<span class="literal">True</span>])</span><br><span class="line"> <span class="built_in">print</span>(a)</span><br><span class="line"> <span class="built_in">print</span>(<span class="built_in">list</span>(a))</span><br><span class="line"><span class="comment">#&lt;filter object at 0x000001D84FB0C390&gt;</span></span><br><span class="line"><span class="comment">#[0, False, True]</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python-map函数</title>
    <url>/2020/05/06/python-map%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="Python-map-函数"><a href="#Python-map-函数" class="headerlink" title="Python map() 函数"></a>Python map() 函数</h3><blockquote>
<p><strong>map()</strong> 会根据提供的函数对指定序列做映射。</p>
<p>第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。</p>
</blockquote>
<span id="more"></span>

<p>类似于php中的array_map()函数</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"> <span class="title function_ invoke__">array_map</span>(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="variable">$n</span></span>)</span>&#123; <span class="keyword">return</span> <span class="variable">$n</span>*<span class="variable">$n</span>;&#125;, <span class="title function_ invoke__">range</span>(<span class="number">0</span>,<span class="number">9</span>)); <span class="comment">#使用function()&#123;&#125;匿名函数</span></span><br><span class="line"><span class="comment">#[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>(<span class="keyword">lambda</span> x: x ** <span class="number">2</span>, <span class="built_in">range</span>(<span class="number">10</span>))  <span class="comment"># 使用 lambda 匿名函数</span></span><br><span class="line"><span class="comment">#[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br><span class="line"></span><br><span class="line">b=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>): 	<span class="comment">#使用for循环逐个遍历</span></span><br><span class="line">    b.append(i**<span class="number">2</span>)</span><br><span class="line"><span class="comment">#[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python with用法</title>
    <url>/2020/05/07/python-with%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span>表达式类似与<span class="keyword">try</span>-<span class="keyword">finally</span>，但又不会捕获异常。</span><br><span class="line"><span class="keyword">with</span> 语句实质是上下文管理。</span><br><span class="line"><span class="number">1</span>、上下文管理协议。包含方法__enter__() 和 __exit__()，支持该协议对象要实现这两个方法。</span><br><span class="line"><span class="number">2</span>、上下文管理器，定义执行<span class="keyword">with</span>语句时要建立的运行时上下文，负责执行<span class="keyword">with</span>语句块上下文中的进入与退出操作。</span><br><span class="line"><span class="number">3</span>、进入上下文的时候执行__enter__方法，如果设置<span class="keyword">as</span> var语句，var变量接受__enter__()方法返回值。</span><br><span class="line"><span class="number">4</span>、如果运行时发生了异常，就退出上下文管理器。调用管理器__exit__方法。</span><br></pre></td></tr></table></figure>
</blockquote>
<span id="more"></span>

<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>context是一个表达式，返回的是一个对象，var用来保存context表达式返回的对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> context [<span class="keyword">as</span> var]:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;1.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(f.read())</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(f.closed) <span class="comment">#true</span></span><br></pre></td></tr></table></figure>

<p>在这段代码中，无论<code>with</code>中的代码块在执行的过程中发生任何情况，文件最终都会被关闭。如果代码块在执行的过程中发生了一个异常，<strong>那么在这个异常被抛出前，程序会先将被打开的文件关闭</strong>。</p>
<h2 id="with-的一般执行过程"><a href="#with-的一般执行过程" class="headerlink" title="with 的一般执行过程"></a>with 的一般执行过程</h2><p>一段基本的<code>with</code>表达式，其结构是这样的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">`<span class="keyword">with</span> EXPR <span class="keyword">as</span> VAR:     BLOCK `</span><br></pre></td></tr></table></figure>

<p>其中：<code>EXPR</code>可以是任意表达式；<code>as VAR</code>是可选的。其一般的执行过程是这样的：</p>
<ol>
<li>计算<code>EXPR</code>，并获取一个上下文管理器。</li>
<li>上下文管理器的<code>__exit()__</code>方法被保存起来用于之后的调用。</li>
<li>调用上下文管理器的<code>__enter()__</code>方法。</li>
<li>如果<code>with</code>表达式包含<code>as VAR</code>，那么<code>EXPR</code>的返回值被赋值给<code>VAR</code>。</li>
<li>执行<code>BLOCK</code>中的表达式。</li>
<li>调用上下文管理器的<code>__exit()__</code>方法。如果<code>BLOCK</code>的执行过程中发生了一个异常导致程序退出，那么异常的<code>type</code>、<code>value</code>和<code>traceback</code>(即<code>sys.exc_info()</code>的返回值)将作为参数传递给<code>__exit()__</code>方法。否则，将传递三个<code>None</code>。</li>
</ol>
<p>将这个过程用代码表示，是这样的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">`mgr = (EXPR) exit = <span class="built_in">type</span>(mgr).__exit__ <span class="comment"># 这里没有执行 value = type(mgr).__enter__(mgr) exc = True  try:     try:         VAR = value # 如果有 as VAR         BLOCK     except:         exc = False         if not exit(mgr, *sys.exc_info()):             raise finally:     if exc:         exit(mgr, None, None, None) `</span></span><br></pre></td></tr></table></figure>

<p>这个过程有几个细节：</p>
<ul>
<li>如果上下文管理器中没有<code>__enter()__</code>或者<code>__exit()__</code>中的任意一个方法，那么解释器会抛出一个<code>AttributeError</code>。</li>
<li>在<code>BLOCK</code>中发生异常后，如果<code>__exit()__</code>方法返回一个可被看成是<code>True</code>的值，那么这个异常就不会被抛出，后面的代码会继续执行。</li>
</ul>
<p>接下来，用两种方法来实现上面来实现上面的过程的吧。</p>
<h2 id="实现上下文管理器类"><a href="#实现上下文管理器类" class="headerlink" title="实现上下文管理器类"></a>实现上下文管理器类</h2><p>第一种方法是实现一个类，其含有一个实例属性<code>db</code>和上下文管理器所需要的方法<code>__enter()__</code>和<code>__exit()__</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">`<span class="keyword">class</span> <span class="title class_">transaction</span>(<span class="title class_ inherited__">object</span>):     <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, db</span>):         self.db = db      <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):         self.db.begin()      <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, <span class="built_in">type</span>, value, traceback</span>):         <span class="keyword">if</span> <span class="built_in">type</span> <span class="keyword">is</span> <span class="literal">None</span>:             db.commit()         <span class="keyword">else</span>:             db.rollback() `</span><br></pre></td></tr></table></figure>

<p>了解<code>with</code>的执行过程后，这个实现方式是很容易理解的。下面介绍的实现方式，其原理理解起来要复杂很多。</p>
<h2 id="使用生成器装饰器"><a href="#使用生成器装饰器" class="headerlink" title="使用生成器装饰器"></a>使用生成器装饰器</h2><p>在Python的标准库中，有一个装饰器可以通过生成器获取上下文管理器。使用生成器装饰器的实现过程如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">`<span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager  @contextmanager <span class="keyword">def</span> <span class="title function_">transaction</span>(<span class="params">db</span>):     db.begin()      <span class="keyword">try</span>:         <span class="keyword">yield</span> db     <span class="keyword">except</span>:         db.rollback()         <span class="keyword">raise</span>     <span class="keyword">else</span>:         db.commit() `</span><br></pre></td></tr></table></figure>

<p>第一眼上看去，这种实现方式更为简单，但是其机制更为复杂。看一下其执行过程吧：</p>
<ol>
<li>Python解释器识别到<code>yield</code>关键字后，<code>def</code>会创建一个生成器函数替代常规的函数（在类定义之外我喜欢用函数代替方法）。</li>
<li>装饰器<code>contextmanager</code>被调用并返回一个帮助函数，这个帮助函数在被调用后会生成一个<code>GeneratorContextManager</code>实例。最终<code>with</code>表达式中的<code>EXPR</code>调用的是由<code>contentmanager</code>装饰器返回的帮助函数。</li>
<li><code>with</code>表达式调用<code>transaction(db)</code>，实际上是调用帮助函数。帮助函数调用生成器函数，生成器函数创建一个生成器。</li>
<li>帮助函数将这个生成器传递给<code>GeneratorContextManager</code>，并创建一个<code>GeneratorContextManager</code>的实例对象作为上下文管理器。</li>
<li><code>with</code>表达式调用实例对象的上下文管理器的<code>__enter()__</code>方法。</li>
<li><code>__enter()__</code>方法中会调用这个生成器的<code>next()</code>方法。这时候，生成器方法会执行到<code>yield db</code>处停止，并将<code>db</code>作为<code>next()</code>的返回值。如果有<code>as VAR</code>，那么它将会被赋值给<code>VAR</code>。</li>
<li><code>with</code>中的<code>BLOCK</code>被执行。</li>
<li><code>BLOCK</code>执行结束后，调用上下文管理器的<code>__exit()__</code>方法。<code>__exit()__</code>方法会再次调用生成器的<code>next()</code>方法。如果发生<code>StopIteration</code>异常，则<code>pass</code>。</li>
<li>如果没有发生异常生成器方法将会执行<code>db.commit()</code>，否则会执行<code>db.rollback()</code>。</li>
</ol>
<p>再次看看上述过程的代码大致实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">`<span class="keyword">def</span> <span class="title function_">contextmanager</span>(<span class="params">func</span>):     <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">*args, **kwargs</span>):         <span class="keyword">return</span> GeneratorContextManager(func(*args, **kwargs))     <span class="keyword">return</span> helper  <span class="keyword">class</span> <span class="title class_">GeneratorContextManager</span>(<span class="title class_ inherited__">object</span>):     <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, gen</span>):         self.gen = gen      <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):         <span class="keyword">try</span>:             <span class="keyword">return</span> self.gen.<span class="built_in">next</span>()         <span class="keyword">except</span> StopIteration:             <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;generator didn&#x27;t yield&quot;</span>)      <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, <span class="built_in">type</span>, value, traceback</span>):         <span class="keyword">if</span> <span class="built_in">type</span> <span class="keyword">is</span> <span class="literal">None</span>:             <span class="keyword">try</span>:                 self.gen.<span class="built_in">next</span>()             <span class="keyword">except</span> StopIteration:                 <span class="keyword">pass</span>             <span class="keyword">else</span>:                 <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;generator didn&#x27;t stop&quot;</span>)         <span class="keyword">else</span>:             <span class="keyword">try</span>:                 self.gen.throw(<span class="built_in">type</span>, value, traceback)                 <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;generator didn&#x27;t stop after throw()&quot;</span>)             <span class="keyword">except</span> StopIteration:                 <span class="keyword">return</span> <span class="literal">True</span>             <span class="keyword">except</span>:                 <span class="keyword">if</span> sys.exc_info()[<span class="number">1</span>] <span class="keyword">is</span> <span class="keyword">not</span> value:                     <span class="keyword">raise</span> `</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Python的<code>with</code>表达式包含了很多Python特性，花点时间吃透<code>with</code>是一件非常值得的事情。</p>
<h2 id="一些其他的例子"><a href="#一些其他的例子" class="headerlink" title="一些其他的例子"></a>一些其他的例子</h2><p>锁机制</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">`@contextmanager <span class="keyword">def</span> <span class="title function_">locked</span>(<span class="params">lock</span>):     lock.acquired()     <span class="keyword">try</span>:         <span class="keyword">yield</span>     <span class="keyword">finally</span>:         lock.release() `</span><br></pre></td></tr></table></figure>

<p>标准输出重定向</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">`@contextmanager <span class="keyword">def</span> <span class="title function_">stdout_redirect</span>(<span class="params">new_stdout</span>):     old_stdout = sys.stdout     sys.stdout = new_stdout     <span class="keyword">try</span>:         <span class="keyword">yield</span>     <span class="keyword">finally</span>:         sys.stdout = old_stdout  <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:     <span class="keyword">with</span> stdout_redirect(f):         <span class="built_in">print</span> <span class="string">&quot;hello world&quot;</span>`</span><br></pre></td></tr></table></figure>

<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="http://preshing.com/20110920/the-python-with-statement-by-example/">The Python “with” Statement by Example</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0343/">PEP 343</a></li>
</ul>
<h3 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h3><p><a href="http://yuez.me/python-zhong-de-guan-jian-zi-with-xiang-jie">http://yuez.me/python-zhong-de-guan-jian-zi-with-xiang-jie</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>在github中建立一个图片库</title>
    <url>/2020/04/18/%E5%9C%A8github%E4%B8%AD%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AA%E5%9B%BE%E7%89%87%E5%BA%93/</url>
    <content><![CDATA[<p>废话少说 就是在GitHub建个库单独存储图片<br>遇到的问题是<br>    <strong>找不到 raw.githubusercontent.com 的服务器 IP 地址。</strong><br>其原因应该就是DNS污染，解决办法<br><strong>在hosts文件添加 199.232.68.133  raw.githubusercontent.com</strong></p>
]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>生成全球唯一标识uuid(python/php)</title>
    <url>/2020/04/24/%E7%94%9F%E6%88%90%E5%85%A8%E7%90%83%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86uuid-python-php/</url>
    <content><![CDATA[<p>UUID（全称为Universally Unique IDentifier）是128位的全局唯一标识符，通常由32字节的字符串表示。</p>
<span id="more"></span>
<h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><p> 在python中有uuid库，它可以通过MAC地址、时间戳、命名空间、随机数、伪随机数来保证生成ID的时间和空间的唯一性。共有五个算法，也就是五种方法来实现：</p>
<h4 id="1、uuid1-——基于时间戳"><a href="#1、uuid1-——基于时间戳" class="headerlink" title="1、uuid1()——基于时间戳"></a>1、uuid1()——基于时间戳</h4><p>由MAC地址、当前时间戳、随机数生成。可以保证全球范围内的唯一性，但MAC的使用同时带来安全性问题，局域网中可以使用IP来代替MAC。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="built_in">print</span>(uuid.uuid1())</span><br></pre></td></tr></table></figure>



<h4 id="2、uuid2-——基于分布式计算环境DCE（Python中没有这个函数）"><a href="#2、uuid2-——基于分布式计算环境DCE（Python中没有这个函数）" class="headerlink" title="2、uuid2()——基于分布式计算环境DCE（Python中没有这个函数）"></a>2、uuid2()——基于分布式计算环境DCE（Python中没有这个函数）</h4><p>算法与uuid1相同，不同的是把时间戳的前4位置换为POSIX的UID。实际中很少用到该方法。</p>
<h4 id="3、uuid3-——基于名字的MD5散列值"><a href="#3、uuid3-——基于名字的MD5散列值" class="headerlink" title="3、uuid3()——基于名字的MD5散列值"></a>3、uuid3()——基于名字的MD5散列值</h4><p>通过计算名字和命名空间的MD5散列值得到，保证了同一命名空间中不同名字的唯一性，和不同命名空间的唯一性，但同一命名空间的同一名字生成相同的uuid。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"></span><br><span class="line">name = <span class="string">&quot;name&quot;</span></span><br><span class="line">namespace = <span class="string">&quot;namespace&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(uuid.uuid3(namespace, name))</span><br></pre></td></tr></table></figure>



<h4 id="4、uuid4-——基于随机数"><a href="#4、uuid4-——基于随机数" class="headerlink" title="4、uuid4()——基于随机数"></a>4、uuid4()——基于随机数</h4><p>由伪随机数得到，有一定的重复概率。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="built_in">print</span>(uuid.uuid4())</span><br></pre></td></tr></table></figure>



<h4 id="5、uuid5-——基于名字的SHA-1散列值"><a href="#5、uuid5-——基于名字的SHA-1散列值" class="headerlink" title="5、uuid5()——基于名字的SHA-1散列值"></a>5、uuid5()——基于名字的SHA-1散列值</h4><p>使用 Secure Hash Algorithm 1 算法代替uuid3中的MD5算法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"></span><br><span class="line">name = <span class="string">&quot;test_name&quot;</span></span><br><span class="line">namespace = <span class="string">&quot;test_namespace&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(uuid.uuid5(namespace, name))</span><br></pre></td></tr></table></figure>



<h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><p>由于php中uuid可以引用安装扩展包，参考 <a href="https://www.cnblogs.com/cndavidwang/p/4018207.html">https://www.cnblogs.com/cndavidwang/p/4018207.html</a></p>
<p> 觉得麻烦也可以直接代码生成</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">sprintf</span>(</span><br><span class="line">            <span class="string">&#x27;%04x%04x-%04x-%04x-%04x-%04x%04x%04x&#x27;</span>,</span><br><span class="line">            <span class="title function_ invoke__">mt_rand</span>(<span class="number">0</span>, <span class="number">0xffff</span>),</span><br><span class="line">            <span class="title function_ invoke__">mt_rand</span>(<span class="number">0</span>, <span class="number">0xffff</span>),</span><br><span class="line">            <span class="title function_ invoke__">mt_rand</span>(<span class="number">0</span>, <span class="number">0xffff</span>),</span><br><span class="line">            <span class="title function_ invoke__">mt_rand</span>(<span class="number">0</span>, <span class="number">0x0fff</span>) | <span class="number">0x4000</span>,</span><br><span class="line">            <span class="title function_ invoke__">mt_rand</span>(<span class="number">0</span>, <span class="number">0x3fff</span>) | <span class="number">0x8000</span>,</span><br><span class="line">            <span class="title function_ invoke__">mt_rand</span>(<span class="number">0</span>, <span class="number">0xffff</span>),</span><br><span class="line">            <span class="title function_ invoke__">mt_rand</span>(<span class="number">0</span>, <span class="number">0xffff</span>),</span><br><span class="line">            <span class="title function_ invoke__">mt_rand</span>(<span class="number">0</span>, <span class="number">0xffff</span>)</span><br><span class="line">        );</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$data</span> = <span class="title function_ invoke__">openssl_random_pseudo_bytes</span>(<span class="number">16</span>);</span><br><span class="line"><span class="variable">$data</span>[<span class="number">6</span>] = <span class="title function_ invoke__">chr</span>(<span class="title function_ invoke__">ord</span>(<span class="variable">$data</span>[<span class="number">6</span>]) &amp; <span class="number">0x0f</span> | <span class="number">0x40</span>); <span class="comment">// set version to 0100</span></span><br><span class="line"><span class="variable">$data</span>[<span class="number">8</span>] = <span class="title function_ invoke__">chr</span>(<span class="title function_ invoke__">ord</span>(<span class="variable">$data</span>[<span class="number">8</span>]) &amp; <span class="number">0x3f</span> | <span class="number">0x80</span>); <span class="comment">// set bits 6-7 to 10</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">vsprintf</span>(<span class="string">&#x27;%s%s-%s-%s-%s-%s%s%s&#x27;</span>, <span class="title function_ invoke__">str_split</span>(<span class="title function_ invoke__">bin2hex</span>(<span class="variable">$data</span>), <span class="number">4</span>));</span><br></pre></td></tr></table></figure>

<p>还有mysql里有自带uuid 函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select UUID();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
        <category>php</category>
      </categories>
      <tags>
        <tag>uuid</tag>
      </tags>
  </entry>
  <entry>
    <title>解决cannot remove &#39;.user.ini&#39;Operation not permitted</title>
    <url>/2020/04/18/%E8%A7%A3%E5%86%B3cannot-remove-user-ini-Operation-not-permitted/</url>
    <content><![CDATA[<p>在Linux中删除整个git仓库，删除失败出现 cannot remove ‘.user.ini’Operation not permitted，原因就是文件中含有某种属性不可更改，删除该属性就可以了</p>
<span id="more"></span>
<p>在Linux中rm -rf的威力是十分巨大的，特别是附带了 -f 参数，不少新手都干过用root用户执行 rm -rf &#x2F;命令这种傻事，如果云服务器没有快照，简直就是灾难，从根目录开始所有文件被递归删除，连系统都被损坏。</p>
<p>但是，偶尔也会遇到使用rm -rf也删除不了的文件，执行后报rm: cannot remove &#96;.user.ini’: Operation not permitted，</p>
<p>这时候需要使用到Linux的chattr命令， chattr命令用于改变文件属性。这项指令可改变存放在ext2文件系统上的文件或目录属性，这些属性共有以下8种模式：<br>a：让文件或目录仅供附加用途。<br>b：不更新文件或目录的最后存取时间。<br>c：将文件或目录压缩后存放。<br>d：将文件或目录排除在倾倒操作之外。<br>i：不得任意更动文件或目录。<br>s：保密性删除文件或目录。<br>S：即时更新文件或目录。<br>u：预防以外删除。<br>语法chattr[-RV][-v&lt;版本编号&gt;][+&#x2F;-&#x2F;&#x3D;&lt;属性&gt;][文件或目录…]参数<br>　　-R 递归处理，将指定目录下的所有文件及子目录一并处理。<br>　　-v&lt;版本编号&gt; 设置文件或目录版本。<br>　　-V 显示指令执行过程。<br>　　+&lt;属性&gt; 开启文件或目录的该项属性。<br>　　-&lt;属性&gt; 关闭文件或目录的该项属性。<br>　　&#x3D;&lt;属性&gt; 指定文件或目录的该项属性。</p>
<p>进入到<code>.user.ini&#39;所在目录，执行一下 lsattr -a，查看文件下下边包含文件的属性，看到</code>.user.ini’有个’i’属性，代表不得任意更动文件或目录，正是此属性在作祟：</p>
<p>然后执行命令：<br><code>chattr -i .user.ini</code><br>就可以去除掉此属性，然后我们再执行删除，就可以顺利删除掉了：</p>
<p>原文链接：<a href="https://blog.csdn.net/sinat_35861727/article/details/79040755">https://blog.csdn.net/sinat_35861727/article/details/79040755</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>测试测试尺寸</title>
    <url>/2022/03/03/%E6%B5%8B%E8%AF%95%E6%B5%8B%E8%AF%95%E5%B0%BA%E5%AF%B8/</url>
    <content><![CDATA[<span id="more"></span>

<img src="E:/飞秋/11_Array：数组_第一天【尚学堂·百战程序员】/文档/images/0.png" style="zoom:200%;" />

<h1 id="Array：数组"><a href="#Array：数组" class="headerlink" title="Array：数组"></a>Array：数组</h1><p><strong>主要内容</strong></p>
<ul>
<li><p>数据类型分类</p>
</li>
<li><p>JVM内存区域初步了解</p>
</li>
<li><p>栈空间</p>
</li>
<li><p>堆空间</p>
</li>
<li><p>字符串常量池</p>
</li>
<li><p>数组</p>
</li>
</ul>
<p><strong>学习目标</strong></p>
<table>
<thead>
<tr>
<th>知识点</th>
<th>要求</th>
</tr>
</thead>
<tbody><tr>
<td>数据类型分类</td>
<td>掌握</td>
</tr>
<tr>
<td>JVM内存区域初步了解</td>
<td>掌握</td>
</tr>
<tr>
<td>栈空间</td>
<td>掌握</td>
</tr>
<tr>
<td>堆空间</td>
<td>掌握</td>
</tr>
<tr>
<td>字符串常量池</td>
<td>掌握</td>
</tr>
<tr>
<td>数组</td>
<td>掌握</td>
</tr>
</tbody></table>
<h2 id="一-数据类型分类"><a href="#一-数据类型分类" class="headerlink" title="一. 数据类型分类"></a>一. 数据类型分类</h2><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><p>​    Java中数据类型分为两大类。</p>
<p>​        1. 八大基本数据类型。简称：<font color='orange'>基本数据类型</font>。</p>
<p>​            <font color='red'>注意:</font> 八大基本数据类型，并不包含八大基本数据类型对应的封装类, 封装类为引用类型</p>
<p>​        2. 引用数据类型。</p>
<p>​            除了八大基本数据类型以外都是引用数据类型。</p>
<p>​        3. 这种分类的依据是这两种数据类型在内存中存储的原理不同。</p>
<p>​        4. <strong>通过学习这两种数据类型在内存中的存储原理以后，要明白两件事情：</strong></p>
<p>​            1. 基本数据类型使用&#x3D;&#x3D;比较, 和引用数据类型使用&#x3D;&#x3D;比较的不同</p>
<p>​            2. 基本数据类型使用&#x3D;赋值, 和引用数据类型使用&#x3D;赋值的不同</p>
<h2 id="二-关键字和保留字"><a href="#二-关键字和保留字" class="headerlink" title="二. 关键字和保留字"></a>二. 关键字和保留字</h2><h3 id="1-介绍-1"><a href="#1-介绍-1" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><p>​    关键字：在当前JDK 版本中具有特殊含义，这些单词都是全小写字母单词。</p>
<p>​    如：<font color='cornflowerblue'>class、if、public、static</font> 都是关键字。</p>
<p>​    保留字：虽然在当前版本中没有特殊含义，但是为了以后版本作为关键字使用。例如：java中没有goto关键字，C++中有goto，就把goto设定为保留字。</p>
<p>​    在IDEA中如果主题是浅色背景模式，所有关键字都是蓝色。</p>
<p> <img src="E:/飞秋/11_Array：数组_第一天【尚学堂·百战程序员】/文档/images/1.png"></p>
<p>​    <font color='red'><strong>无论是关键字还是保留字都不允许作为包名、类名、变量名</strong>。</font></p>
<p> <img src="E:/飞秋/11_Array：数组_第一天【尚学堂·百战程序员】/文档/images/2.png"></p>
<h3 id="2-关键字和保留字表"><a href="#2-关键字和保留字表" class="headerlink" title="2. 关键字和保留字表"></a>2. 关键字和保留字表</h3><p>​    我们不用刻意去记哪些是关键字，哪些是保留字。随着不断的学习，那些具有特殊含义的单词，都不要作为包名、类名、变量名就可以了。</p>
<table>
<thead>
<tr>
<th>abstract</th>
<th>assert</th>
<th>boolean</th>
<th>break</th>
<th>byte</th>
<th>case</th>
</tr>
</thead>
<tbody><tr>
<td>catch</td>
<td>char</td>
<td>class</td>
<td>const</td>
<td>continue</td>
<td>default</td>
</tr>
<tr>
<td>do</td>
<td>double</td>
<td>else</td>
<td>extends</td>
<td>final</td>
<td>finally</td>
</tr>
<tr>
<td>float</td>
<td>for</td>
<td>goto</td>
<td>if</td>
<td>implements</td>
<td>import</td>
</tr>
<tr>
<td>instanceof</td>
<td>int</td>
<td>interface</td>
<td>long</td>
<td>native</td>
<td>new</td>
</tr>
<tr>
<td>null</td>
<td>package</td>
<td>private</td>
<td>protected</td>
<td>public</td>
<td>return</td>
</tr>
<tr>
<td>short</td>
<td>static</td>
<td>strictfp</td>
<td>super</td>
<td>switch</td>
<td>synchronized</td>
</tr>
<tr>
<td>this</td>
<td>throw</td>
<td>throws</td>
<td>transient</td>
<td>try</td>
<td>void</td>
</tr>
<tr>
<td>volatile</td>
<td>while</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="三-JVM内存区域初步了解"><a href="#三-JVM内存区域初步了解" class="headerlink" title="三. JVM内存区域初步了解"></a>三. JVM内存区域初步了解</h2><h3 id="1-介绍-2"><a href="#1-介绍-2" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><p>​    在计算机中任何运行的程序都是在<font color='orange'><strong>内存</strong></font>中的。所以Java应用程序也不例外。</p>
<p>​    学习好Java程序内存原理，对于理解Java底层和未来的面试有很大的帮助。</p>
<p>​    JVM运行在内存中，为了提高效率对整个空间做了不同区域的划分，而在JVM中有两个非常重要的内存空间。一个是堆，另一个是栈。</p>
<p> <img src="E:/飞秋/11_Array：数组_第一天【尚学堂·百战程序员】/文档/images/3.png"></p>
<p>​    注意：</p>
<p>​        1. 此处的堆和栈跟数据结构中的堆和栈是完全不同的两个东西。</p>
<p>​        2. 堆和栈都是内存中一块空间。</p>
<p>​        3. Java 8 和Java 7和Java 6在内存原理中有一定的区别，预科阶段我们只考虑Java 8的。</p>
<p>​        4. JVM内存结构中不仅仅有堆和栈。<font color='orange'>预科阶段我们先学习堆和栈</font>。</p>
<p>​        5. <font color='cornflowerblue'>由于目前我们只学习了局部变量（方法里面定义变量），所以目前我们只考虑的是局部变量的内存存储原理。</font></p>
<h2 id="四-栈空间-Stack"><a href="#四-栈空间-Stack" class="headerlink" title="四. 栈空间(Stack)"></a>四. 栈空间(Stack)</h2><p>​    栈：一块存储**<font color='cornflowerblue'>八大基本数据类型值 和 引用数据类型地址</font>**的内存空间。</p>
<p>​    栈中数据的特点：</p>
<p>​        有效时间固定。</p>
<h3 id="1-存储时间固定"><a href="#1-存储时间固定" class="headerlink" title="1. 存储时间固定"></a>1. 存储时间固定</h3><p>​    存储时间固定中的，不是说固定1秒，固定2秒。而是会跟随方法(代码块)的执行完成进行回收。回收后的空间可以立即被其他人使用。整个回收过程不需要程序员进行参与。</p>
<p> <img src="E:/飞秋/11_Array：数组_第一天【尚学堂·百战程序员】/文档/images/4.png"></p>
<h3 id="2-八大基本数据使用-x3D-x3D"><a href="#2-八大基本数据使用-x3D-x3D" class="headerlink" title="2. 八大基本数据使用&#x3D;&#x3D;"></a>2. 八大基本数据使用&#x3D;&#x3D;</h3><p>​    Java中基本数据类型使用 &#x3D;&#x3D; 比较, 比较的是存储的值。</p>
<p>​    由于基本数据类型在栈空间中存储的特性，<font color='red'>&#x3D;&#x3D;对于八大基本数据类型比较的是值</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">System.out.println(a == b);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h3 id="3-八大基本数据类型的赋值"><a href="#3-八大基本数据类型的赋值" class="headerlink" title="3. 八大基本数据类型的赋值"></a>3. 八大基本数据类型的赋值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a;</span><br></pre></td></tr></table></figure>

<p>​    根据上面讲解的原理，八大基本数据类型中，栈中存储的就是实际的值。所以当我们把变量a赋值给变量b时，在栈空间中变量b的值和变量a的值就是相等的</p>
<p>​    如果在上面代码基础上，添加b&#x3D;2;栈空间的变化又是什么呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a;</span><br><span class="line">b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>​    在栈空间中变量b的值变为2, 而变量a的值还是1</p>
<p>​    强调：“**<font color='red'>八大基本数据类型在赋值时，传递的是值</font>**”。</p>
<h3 id="4-结论验证"><a href="#4-结论验证" class="headerlink" title="4. 结论验证"></a>4. 结论验证</h3><p>​    请说明下面代码的输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">System.out.println(b == <span class="number">1</span>);</span><br><span class="line">System.out.println(a == b);</span><br><span class="line">System.out.println(a == c);</span><br><span class="line">System.out.println(b == c);</span><br></pre></td></tr></table></figure>



<h2 id="五-堆空间"><a href="#五-堆空间" class="headerlink" title="五. 堆空间"></a>五. 堆空间</h2><h3 id="1-堆空间介绍"><a href="#1-堆空间介绍" class="headerlink" title="1. 堆空间介绍"></a>1. 堆空间介绍</h3><p>​    堆(Heap): 里面存储java中所有引用数据类型的内容。</p>
<p>​    所有引用数据类型的实际值都存储到堆里面。 在栈空间中存储引用数据类型的值在堆中的地址。</p>
<p>​    也就是说：在代码中引用数据类型变量里面只存储了数据在堆中的地址。</p>
<h3 id="2-引用类型在堆空间中的原理"><a href="#2-引用类型在堆空间中的原理" class="headerlink" title="2. 引用类型在堆空间中的原理"></a>2. 引用类型在堆空间中的原理</h3><p>​    例如：Integer a &#x3D; new Integer(123);对应的内存示意图如下：</p>
<p> <img src="E:/飞秋/11_Array：数组_第一天【尚学堂·百战程序员】/文档/images/5.png"></p>
<p>​    堆空间中和栈空间存储原理是不一样的。堆中的数据是由Java GC进行回收的（<font color='orange'>不会立即回收</font>）。</p>
<p>​    绝大多数引用数据类型需要使用时都需要通过<font color='orange'>new</font> 关键字(具有特殊含义的单词，类名和变量名和包名都不能是关键字)，每一次执行<font color='red'><strong>new时都会在堆中重新申请一块空间</strong></font>。</p>
<p>​    重新申请空间后，将地址存储在栈空间中, 所以两个值的地址就不一样了。</p>
<p>​    引用类型使用 &#x3D; &#x3D;比较时必须注意</p>
<p> <img src="E:/飞秋/11_Array：数组_第一天【尚学堂·百战程序员】/文档/images/6.png"></p>
<p>​    所以在使用封装类Integer时&#x3D;&#x3D;比较结果为false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">System.out.println(a == b);</span><br></pre></td></tr></table></figure>

<h3 id="3-引用数据类型赋值"><a href="#3-引用数据类型赋值" class="headerlink" title="3. 引用数据类型赋值"></a>3. 引用数据类型赋值</h3><p>​    局部变量都是存储在栈空间中, 所以引用类型在栈中存储的是在堆空间中开辟的地址。</p>
<p>​    所以：把一个引用数据类型赋值给另一个引用数据类型时，<font color='orange'>传递的是地址</font>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> a;</span><br><span class="line">System.out.println(a == b); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h3 id="4-基本数据类型和封装类比较时"><a href="#4-基本数据类型和封装类比较时" class="headerlink" title="4. 基本数据类型和封装类比较时"></a>4. 基本数据类型和封装类比较时</h3><p>对于<font color='cornflowerblue'>基本数据类型</font>和<font color='cornflowerblue'>封装类</font>进行<font color='orange'>比较</font>时. 编译器都按照<font color='cornflowerblue'>两侧是基本数据类型</font>进行看待。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">System.out.println(a == b); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>



<h2 id="六-字符串常量池"><a href="#六-字符串常量池" class="headerlink" title="六. 字符串常量池"></a>六. 字符串常量池</h2><h3 id="1-知识点回顾"><a href="#1-知识点回顾" class="headerlink" title="1. 知识点回顾"></a>1. 知识点回顾</h3><p>​    在使用String类型时允许有两种方式实例化String对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;北京尚学堂&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">name2</span> <span class="operator">=</span> <span class="string">&quot;北京尚学堂&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>​    以上两种方式都是将字符串的值存储在了<font color='orange'>字符串常量池中</font></p>
<p>​    第一种方式:</p>
<p>​        使用new关键字, 会在堆空间中开辟空间, 将堆中开辟空间的地址存储在栈空间中, 字符串的值会存储在字符串常量池中, 字符串常量池中的地址存储在堆空间中</p>
<p>​    第二种方式:</p>
<p>​        将字符串放入常量池中, 字符串常量池中的地址存储在栈空间中</p>
<h3 id="2-字符串常量池"><a href="#2-字符串常量池" class="headerlink" title="2. 字符串常量池"></a>2. 字符串常量池</h3><p>​    字符串常量池是<font color='cornflowerblue'><strong>堆空间里面</strong></font>一块专门存放字符串值的空间。</p>
<p>​    当我们使用String name&#x3D;””; 这种形式实例化字符串类型变量时，会把值存放在字符串常量池中。</p>
<p>​    如果字符串的值已经在常量池中则直接返回存在的地址不会再新添加。</p>
<p>​    如果字符串值没有在字符串常量池中，会新开辟一块空间存放字符串值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name1</span> <span class="operator">=</span> <span class="string">&quot;北京尚学堂&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">name2</span> <span class="operator">=</span> <span class="string">&quot;北京尚学堂&quot;</span>;</span><br><span class="line">System.out.println(name1 == name2); <span class="comment">//true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    所以上面代码中name1和name2使用双等号比较地址时是相等的。</p>
<p> <img src="E:/飞秋/11_Array：数组_第一天【尚学堂·百战程序员】/文档/images/7.png"></p>
<h3 id="3-new-String"><a href="#3-new-String" class="headerlink" title="3. new String"></a>3. new String</h3><p>​    如果使用String name &#x3D; new String();形式时，将字符串的值存放在字符创常量池中, 堆空间中存放字符串常量池中的地址, 栈空间中存储堆空间的地址。</p>
<p>​    谨记：<font color='red'><strong>在Java中只要new，一定会在堆中开辟新空间</strong></font>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;北京尚学堂&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">name2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;北京尚学堂&quot;</span>);</span><br><span class="line">System.out.println(name1 == name2); <span class="comment">//false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <img src="E:/飞秋/11_Array：数组_第一天【尚学堂·百战程序员】/文档/images/8.png"></p>
<h3 id="4-字面量和new方式比较"><a href="#4-字面量和new方式比较" class="headerlink" title="4. 字面量和new方式比较"></a>4. 字面量和new方式比较</h3><p>​    字面量：等号右侧的表达式或固定值称为字面量。</p>
<p>​    例如: String name&#x3D;”北京尚学堂”; 北京尚学堂 就是字面量。</p>
<p>​    当我们使用字面量和new String方式产生的对象进行比较时结果是什么呢？</p>
<p>​    只要new 就是开辟新空间，双等号比较的地址就是不一样的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;北京尚学堂&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">name2</span> <span class="operator">=</span> <span class="string">&quot;北京尚学堂&quot;</span>;</span><br><span class="line">System.out.println(name1 == name2); <span class="comment">//false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <img src="E:/飞秋/11_Array：数组_第一天【尚学堂·百战程序员】/文档/images/9.png"></p>
<h3 id="5-intern-方法"><a href="#5-intern-方法" class="headerlink" title="5. intern() 方法"></a>5. intern() 方法</h3><p>​    Java中String类中有intern()方法，调用inern()方法时，会返回字符串常量池中的地址。</p>
<p>​    执行流程:</p>
<pre><code>1. 执行了new String(“北京尚学堂”); 就已经将字符串放入了字符串常量池中
2. 调用inern()方法时，会返回该字符串在字符串常量池中的地址
</code></pre>
<ol start="3">
<li>尽管在输出中调用intern方法并没有什么效果，但是实际上后台这个方法会做一系列的动作和操作。在调用”bjsxt”.intern()方法的时候会返回”bjsxt”，但是这个方法会首先检查字符串池中是否有”bjsxt”这个字符串，如果存在则返回这个字符串的引用，否则就将这个字符串添加到字符串池中，然会返回这个字符串的引用</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;北京尚学堂&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">name2</span> <span class="operator">=</span> <span class="string">&quot;北京尚学堂&quot;</span>;</span><br><span class="line">System.out.println(name1 == name2); <span class="comment">//false</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name3</span> <span class="operator">=</span> name1.intern();</span><br><span class="line">System.out.println(name2 == name3); <span class="comment">//true</span></span><br><span class="line">System.out.println(name1 == name3); <span class="comment">//false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <img src="E:/飞秋/11_Array：数组_第一天【尚学堂·百战程序员】/文档/images/10.png"></p>
<h3 id="6-综合结论"><a href="#6-综合结论" class="headerlink" title="6. 综合结论"></a>6. 综合结论</h3><p>​    在多个String类型变量中存放相同值时，使用双等号判断内存地址，有的时候为true，有的时候为false。</p>
<p>​    所以，在开发中，为了保险起见。在对String 类型中存放的值进行比较时，一定要用equals()方法进行比较。如果相等返回true，如果不相等返回false。</p>
<p>​    引用类型进行比较时:</p>
<p>​        1. &#x3D;&#x3D; :  比较的是地址</p>
<p>​        2. equals():  比较的是实际存储的值</p>
<h2 id="七-数组"><a href="#七-数组" class="headerlink" title="七. 数组"></a>七. 数组</h2><h3 id="1-为什么使用数组"><a href="#1-为什么使用数组" class="headerlink" title="1. 为什么使用数组"></a>1. 为什么使用数组</h3><p>​    在我们上次课中最后一个综合作业里面，要求：录入商品时需要录入固定数量的两个商品，这是我们就需要提供四个变量分别存储两个商品的名称和价格。 </p>
<p>​    那么如果我希望一次录入10个商品呢？这个时候时候是需要定义20个变量。</p>
<p>​    那么如果我希望一次录入100个商品呢？这个时候是需要定义200个变量。</p>
<p>​    显然，当商品数量比较多时，定义大量变量是比较复杂的，这个时候，如果Java给我们提供一种可以<font color='cornflowerblue'><strong>一个变量存放多个值</strong></font>的结构，是不是就比较简单了。</p>
<p>​    这个时候数组就顺势而生了。</p>
<h3 id="2-数组介绍"><a href="#2-数组介绍" class="headerlink" title="2. 数组介绍"></a>2. 数组介绍</h3><p>​    数组是一种可以存放<font color='red'><strong>固定个数</strong></font>的**<font color='red'>相同类型</font><strong>数据的有序集合,</strong><font color='red'>数组是引用数据类型</font>**。</p>
<p><img src="E:/飞秋/11_Array：数组_第一天【尚学堂·百战程序员】/文档/images/image-20220226162138079.png" alt="image-20220226162138079"> </p>
<p>​    一旦定义好数组长度就是不能改变的。这时会在堆中申请一块连续空间用于存放数组中的值。数组长度最大值为int类型最大值。（前提内存足够大）</p>
<p><img src="E:/飞秋/11_Array：数组_第一天【尚学堂·百战程序员】/文档/images/image-20220226162154956.png" alt="image-20220226162154956"> </p>
<p>​    通过上面定义，我们要知道：<font color='red'><strong>（重点）</strong></font></p>
<ol>
<li><p>长度是确定的。数组一旦被创建，它的大小就是不可以改变的。</p>
</li>
<li><p>在内存中分配连续的空间，每个元素占用的空间大小是相同的</p>
</li>
<li><p>同一个数组其元素的类型必须是相同类型，不允许出现混合类型</p>
</li>
<li><p>数组类型可以是任何数据类型，包括基本类型和引用类型</p>
</li>
<li><p>数组变量属于引用数据类型</p>
</li>
</ol>
<h3 id="3-数组定义语法"><a href="#3-数组定义语法" class="headerlink" title="3. 数组定义语法"></a>3. 数组定义语法</h3><h4 id="3-1-声明数组"><a href="#3-1-声明数组" class="headerlink" title="3.1 声明数组"></a>3.1 声明数组</h4><p>​    语法:</p>
<p>​         <strong><font color='cornflowerblue'>类型[]  对象名;</font></strong>  </p>
<p>​         <strong><font color='cornflowerblue'>类型  对象名[];</font></strong>  </p>
<p>​    其中类型就是数组中每个值(元素)的类型，不允许存储其他类型的值。</p>
<p>​    例如:</p>
<p>​        int[] arr;</p>
<p>​        int arr[];</p>
<p>​        这时只是声明了数组，但是并没有在内存中申请空间. 并不允许获取数组中值，因为还没有开辟空间。</p>
<h4 id="3-2-声明并赋值"><a href="#3-2-声明并赋值" class="headerlink" title="3.2 声明并赋值"></a>3.2 <strong>声明并赋值</strong></h4><p>​    创建数组并给定初始值的语法有多种，<font color='red'><strong>前后类型必须相同</strong></font>。</p>
<p>​    数据类型[] 对象名 &#x3D; {值1, 值2, 值3, …};</p>
<p>​    数据类型[] 对象名 &#x3D; new 数据类型[]{值1, 值2, 值3, …};</p>
<p>​    数据类型[] 对象名 &#x3D; new 数据类型[长度];</p>
<p>​    例如:</p>
<p>​        int[] arr &#x3D; {1, 2, 3};</p>
<p>​        int[] arr1 &#x3D; new int[]{1, 2, 3};</p>
<p>​        int[] arr2 &#x3D; new int[3];</p>
<p>​        第一种：创建了长度为3，元素类型为int的数组，数组中值分别为1，2，3</p>
<p>​        第二种：创建了长度为3，元素类型为int的数组，数组中值分别为1，2，3</p>
<p>​        第三种：创建了长度为3，元素类型为int的数组，数组中值使用int默认值0</p>
<h4 id="3-3-数组中元素的默认值"><a href="#3-3-数组中元素的默认值" class="headerlink" title="3.3 数组中元素的默认值"></a>3.3 数组中元素的默认值</h4><table>
<thead>
<tr>
<th>类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>0</td>
</tr>
<tr>
<td>short</td>
<td>0</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0</td>
</tr>
<tr>
<td>float</td>
<td>0.0</td>
</tr>
<tr>
<td>double</td>
<td>0.0</td>
</tr>
<tr>
<td>char</td>
<td>空格（’\u0000’）</td>
</tr>
<tr>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>String及其他引用数据类型（包含八大基本数据类型的封装类）</td>
<td>null强调：String取值可以为””。null表示未初始化，没有分配内容空间。””表示已经实例化，只是存的值为空白。</td>
</tr>
</tbody></table>
<h3 id="4-获取数组中的元素"><a href="#4-获取数组中的元素" class="headerlink" title="4. 获取数组中的元素"></a>4. 获取数组中的元素</h3><p>​    如果只想获取数组一个值，可以使用从0开始的脚标。</p>
<p>​    一个长度为N的数组，其脚标的取值范围：<font color='red'>0&lt;&#x3D;脚标&lt;&#x3D;N-1</font></p>
<p>​    语法:</p>
<p>​        <font color='cornflowerblue'><strong>数据类型 变量名 &#x3D; 数组对象[脚标]</strong></font></p>
<p>​    例如我们定义一个这样的数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    如果我想要获取里面第三个元素，应该这</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr[<span class="number">2</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    因为数组长度是固定的，如果我想要获取里面第6个元素的值，这时已经超出了数组的空间，程序会报错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> arr[<span class="number">6</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <img src="E:/飞秋/11_Array：数组_第一天【尚学堂·百战程序员】/文档/images/12.png"></p>
<p><strong><font color='red'>所以千万不要超过数组的最大脚标。脚标最大值为数组长度-1</font></strong></p>
<h3 id="5-修改数组中元素值"><a href="#5-修改数组中元素值" class="headerlink" title="5. 修改数组中元素值"></a>5. 修改数组中元素值</h3><p>​    如果想要修改数组中某个元素的值。可以通过脚标设置这个元素值</p>
<p>​    语法：</p>
<p>​        <strong><font color='cornflowerblue'>数组对象[脚标] &#x3D; 值;</font></strong></p>
<p>​    例如：先设置数组中第三个元素的值，然后在获取第三个元素的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> arr[<span class="number">2</span>];</span><br><span class="line">System.out.println(i2);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    和获取值是一个道理：**<font color='red'>脚标不允许超过数组最大脚标，脚标最大值为数组长度-1</font>**</p>
<h3 id="6-数组常用属性"><a href="#6-数组常用属性" class="headerlink" title="6. 数组常用属性"></a>6. 数组常用属性</h3><p>​    属性就是类中的全局变量。</p>
<p>​    数组类型最常用的属性就是<font color='orange'>length</font>，使用length获取数组的长度。</p>
<p>​     一定要注意，length没有括号。length是属性，不是方法。</p>
<p>​    语法：</p>
<p>​        <strong><font color='cornflowerblue'>数组对象.length</font></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="7-遍历数组"><a href="#7-遍历数组" class="headerlink" title="7. 遍历数组"></a>7. 遍历数组</h3><h4 id="7-1-普通for循环"><a href="#7-1-普通for循环" class="headerlink" title="7.1 普通for循环"></a>7.1 普通for循环</h4><p>​    数组中的脚标都是从0开始的整数，如果希望把数组中所有值都输出出来，可以使用for循环进行遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="7-2-增强for循环"><a href="#7-2-增强for循环" class="headerlink" title="7.2 增强for循环"></a>7.2 增强for循环</h4><p>​    在Java中支持for循环的另一种写法，称为增强for循环</p>
<p>​    语法：</p>
<p>​        <strong><font color='cornflowerblue'>for(类型 : 迭代变量){</font></strong></p>
<p>​        <font color='cornflowerblue'><strong>}</strong></font></p>
<p>​    代码实例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i : arr)&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="8-数组内存结构"><a href="#8-数组内存结构" class="headerlink" title="8. 数组内存结构"></a>8. 数组内存结构</h3><p>​    因为数组是一块连续的空间，虽然元素的地址是连续的，但是因为有多个元素，那就有多个地址，但是栈空间中只能存放一个地址引用。</p>
<p><font color='orange'>    <strong>所以数组对象中存放的是数组空间中第一个元素的地址</strong>。</font></p>
<p> <img src="E:/飞秋/11_Array：数组_第一天【尚学堂·百战程序员】/文档/images/11.png"></p>
<h2 id="八、小节实战案例-只有程序员才懂的电话号码"><a href="#八、小节实战案例-只有程序员才懂的电话号码" class="headerlink" title="八、小节实战案例-只有程序员才懂的电话号码"></a>八、小节实战案例-只有程序员才懂的电话号码</h2><p> <img src="E:/飞秋/11_Array：数组_第一天【尚学堂·百战程序员】/文档/images/13.png"></p>
<h2 id="九-小节实战案例-求平均数"><a href="#九-小节实战案例-求平均数" class="headerlink" title="九. 小节实战案例 - 求平均数"></a>九. 小节实战案例 - 求平均数</h2><h3 id="1-需求"><a href="#1-需求" class="headerlink" title="1. 需求"></a>1. 需求</h3><p>​    在控制台输入5个整数数字，最后输出输入的五个数字，以及平均值。</p>
<p>​    效果图:</p>
<p> <img src="E:/飞秋/11_Array：数组_第一天【尚学堂·百战程序员】/文档/images/14.png"></p>
<h3 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//在控制台输入5个整数数字，最后输出输入的五个数字，以及平均值。</span></span><br><span class="line">    <span class="comment">//循环 : 固定次数的循环  for</span></span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="comment">//声明一个数组, 并指定数组长度为5</span></span><br><span class="line">    <span class="type">int</span>[] ints = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环5次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入第 &quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot; 个数字&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="comment">//将数字存储到数组中</span></span><br><span class="line">        ints[i] = i1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出5个数字(5个数字在数组中), 遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> anInt : ints) &#123;</span><br><span class="line">        System.out.print(anInt+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算所有数字的和</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//5个数字的和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> anInt : ints) &#123;</span><br><span class="line">        sum+=anInt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算平均数  5个数字的和/数组的长度</span></span><br><span class="line">    System.out.println(<span class="string">&quot;5个数字的和为: &quot;</span>+sum);</span><br><span class="line">    System.out.println(<span class="string">&quot;平均数为: &quot;</span>+sum/ints.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="十-小节实战案例-改写简易超市管理系统"><a href="#十-小节实战案例-改写简易超市管理系统" class="headerlink" title="十. 小节实战案例 - 改写简易超市管理系统"></a>十. 小节实战案例 - 改写简易超市管理系统</h2><h3 id="1-需求-1"><a href="#1-需求-1" class="headerlink" title="1. 需求"></a>1. 需求</h3><p>​    1. 录入商品时最多可以录入200个数据。</p>
<p>​    2. 通过一个整型变量存储目前商品库存数。</p>
<p>​    3. 每次录入完成后会提示用户是否继续输入，如果输入y，继续输入。否则停止输入。</p>
<p>​    4. 选择菜单2时输出的信息为数组中实际库存的商品信息。默认值不要输出。</p>
<p><strong><font color='cornflowerblue'>菜单1效果图：</font></strong></p>
<p> <img src="E:/飞秋/11_Array：数组_第一天【尚学堂·百战程序员】/文档/images/15.png"></p>
<p><strong><font color='cornflowerblue'>菜单2效果图：</font></strong></p>
<p> <img src="E:/飞秋/11_Array：数组_第一天【尚学堂·百战程序员】/文档/images/16.png"></p>
<h3 id="2-实现-1"><a href="#2-实现-1" class="headerlink" title="2. 实现"></a>2. 实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="comment">//存储商品名称的数组</span></span><br><span class="line">    String[] names = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">200</span>];</span><br><span class="line">    <span class="comment">//存储商品价格的数组</span></span><br><span class="line">    <span class="type">double</span>[] privces = <span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">200</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//计数器</span></span><br><span class="line">    System.out.println(<span class="string">&quot;欢迎使用简易超市管理系统&quot;</span>);</span><br><span class="line">    o: <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n请选择要完成的事: &quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1.录入商品&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;2.查看商品&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;3.退出系统&quot;</span>);</span><br><span class="line">        <span class="comment">//接收用户输入的选项</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="comment">//根据不同的选择, 完成不同操作</span></span><br><span class="line">        <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">//录入商品</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;\n是否要录入商品? y|n&quot;</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">next</span> <span class="operator">=</span> sc.next(); <span class="comment">//接收用户输入的选择</span></span><br><span class="line">                    <span class="comment">//不等于y时执行</span></span><br><span class="line">                    <span class="keyword">if</span> (!<span class="string">&quot;y&quot;</span>.equals(next)) &#123;<span class="comment">// String  引用类型, 判断需要使用 equals()方法</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;请输入商品名称: &quot;</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> sc.next(); <span class="comment">//接收商品名称</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;请输入商品价格: &quot;</span>);</span><br><span class="line">                    <span class="type">double</span> <span class="variable">privce</span> <span class="operator">=</span> sc.nextDouble();</span><br><span class="line">                    <span class="comment">//存储多个商品信息, 需要数组进行存储</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">/* 向数组中添加元素, 根据下标添加  */</span></span><br><span class="line">                    <span class="comment">//将商品名称添加到存储名称的数组中</span></span><br><span class="line">                    names[count] = name;</span><br><span class="line">                    <span class="comment">//将商品价格添加到存储价格的数组中</span></span><br><span class="line">                    privces[count] = privce;</span><br><span class="line">                    <span class="comment">//添加完一个商品信息之后需要将count+1</span></span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;\n商品名称\t商品价格&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">0</span>; i1 &lt; count; i1++) &#123;</span><br><span class="line">                    System.out.println(names[i1] + <span class="string">&quot;\t&quot;</span> + privces[i1]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">break</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
</search>
